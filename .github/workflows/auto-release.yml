name: Automated Release & Deployment

on:
  push:
    branches: [ main, master ]
    paths-ignore:
      - 'README.md'
      - 'docs/**'
      - '.github/workflows/**'
  workflow_dispatch:
    inputs:
      release_type:
        description: 'Release type'
        required: true
        default: 'patch'
        type: choice
        options:
          - patch
          - minor
          - major

jobs:
  detect-changes:
    runs-on: ubuntu-latest
    outputs:
      should-release: ${{ steps.changes.outputs.should-release }}
      release-type: ${{ steps.changes.outputs.release-type }}
      has-python: ${{ steps.detect.outputs.has-python }}
      has-node: ${{ steps.detect.outputs.has-node }}
      has-rust: ${{ steps.detect.outputs.has-rust }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Detect project type
        id: detect
        run: |
          echo "has-python=$([ -f setup.py ] || [ -f pyproject.toml ] && echo 'true' || echo 'false')" >> $GITHUB_OUTPUT
          echo "has-node=$([ -f package.json ] && echo 'true' || echo 'false')" >> $GITHUB_OUTPUT
          echo "has-rust=$([ -f Cargo.toml ] && echo 'true' || echo 'false')" >> $GITHUB_OUTPUT
      
      - name: Analyze changes for release
        id: changes
        run: |
          # Check if this is a manual release
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "should-release=true" >> $GITHUB_OUTPUT
            echo "release-type=${{ github.event.inputs.release_type }}" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Get the last two commits
          recent_commits=$(git log --oneline -n 10 --pretty=format:"%s")
          
          # Determine release type based on commit messages
          if echo "$recent_commits" | grep -i "breaking\|major\|BREAKING CHANGE"; then
            echo "should-release=true" >> $GITHUB_OUTPUT
            echo "release-type=major" >> $GITHUB_OUTPUT
          elif echo "$recent_commits" | grep -i "feat\|feature\|add\|new"; then
            echo "should-release=true" >> $GITHUB_OUTPUT
            echo "release-type=minor" >> $GITHUB_OUTPUT
          elif echo "$recent_commits" | grep -i "fix\|bug\|patch\|hotfix"; then
            echo "should-release=true" >> $GITHUB_OUTPUT
            echo "release-type=patch" >> $GITHUB_OUTPUT
          else
            echo "should-release=false" >> $GITHUB_OUTPUT
            echo "release-type=none" >> $GITHUB_OUTPUT
          fi

  create-release:
    runs-on: ubuntu-latest
    needs: detect-changes
    if: needs.detect-changes.outputs.should-release == 'true'
    outputs:
      new-version: ${{ steps.version.outputs.new-version }}
      release-notes: ${{ steps.changelog.outputs.release-notes }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Setup Node.js for version management
        uses: actions/setup-node@v4
        with:
          node-version: '18'
      
      - name: Install semver tool
        run: npm install -g semver
      
      - name: Determine current version
        id: current-version
        run: |
          # Try to get version from different sources
          if [ -f package.json ]; then
            current_version=$(node -p "require('./package.json').version" 2>/dev/null || echo "0.0.0")
          elif [ -f pyproject.toml ]; then
            current_version=$(grep -E '^version = ' pyproject.toml | sed 's/version = "\(.*\)"/\1/' || echo "0.0.0")
          elif [ -f Cargo.toml ]; then
            current_version=$(grep -E '^version = ' Cargo.toml | sed 's/version = "\(.*\)"/\1/' || echo "0.0.0")
          else
            # Get from git tags
            current_version=$(git describe --tags --abbrev=0 2>/dev/null | sed 's/^v//' || echo "0.0.0")
          fi
          
          echo "current-version=$current_version" >> $GITHUB_OUTPUT
          echo "Current version: $current_version"
      
      - name: Calculate new version
        id: version
        run: |
          current="${{ steps.current-version.outputs.current-version }}"
          release_type="${{ needs.detect-changes.outputs.release-type }}"
          
          new_version=$(semver -i $release_type $current)
          echo "new-version=$new_version" >> $GITHUB_OUTPUT
          echo "New version: $new_version"
      
      - name: Update version files
        run: |
          new_version="${{ steps.version.outputs.new-version }}"
          
          # Update package.json
          if [ -f package.json ]; then
            npm version $new_version --no-git-tag-version
            echo "‚úÖ Updated package.json to $new_version"
          fi
          
          # Update pyproject.toml
          if [ -f pyproject.toml ]; then
            sed -i "s/^version = .*/version = \"$new_version\"/" pyproject.toml
            echo "‚úÖ Updated pyproject.toml to $new_version"
          fi
          
          # Update Cargo.toml
          if [ -f Cargo.toml ]; then
            sed -i "s/^version = .*/version = \"$new_version\"/" Cargo.toml
            echo "‚úÖ Updated Cargo.toml to $new_version"
          fi
      
      - name: Generate changelog
        id: changelog
        run: |
          echo "üìù Generating changelog..."
          
          # Get commits since last tag
          last_tag=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
          if [ -z "$last_tag" ]; then
            commits=$(git log --oneline --pretty=format:"- %s" -n 20)
          else
            commits=$(git log ${last_tag}..HEAD --oneline --pretty=format:"- %s")
          fi
          
          # Create release notes
          cat > release_notes.md << EOF
          ## What's Changed
          
          $commits
          
          **Full Changelog**: https://github.com/${{ github.repository }}/compare/${last_tag}...v${{ steps.version.outputs.new-version }}
          EOF
          
          echo "release-notes<<EOF" >> $GITHUB_OUTPUT
          cat release_notes.md >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
      
      - name: Commit version changes
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add -A
          git commit -m "chore: bump version to ${{ steps.version.outputs.new-version }}" || exit 0
          git push
      
      - name: Create GitHub release
        uses: actions/github-script@v7
        with:
          script: |
            const { context, github } = require('@actions/github');
            
            const release = await github.rest.repos.createRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              tag_name: 'v${{ steps.version.outputs.new-version }}',
              name: 'Release v${{ steps.version.outputs.new-version }}',
              body: `${{ steps.changelog.outputs.release-notes }}`,
              draft: false,
              prerelease: false
            });
            
            console.log(`Created release: ${release.data.html_url}`);

  publish-python:
    runs-on: ubuntu-latest
    needs: [detect-changes, create-release]
    if: needs.detect-changes.outputs.has-python == 'true' && needs.detect-changes.outputs.should-release == 'true'
    steps:
      - uses: actions/checkout@v4
        with:
          ref: main
      
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
      
      - name: Install build tools
        run: |
          python -m pip install --upgrade pip
          pip install build twine
      
      - name: Build package
        run: |
          python -m build
          echo "‚úÖ Python package built successfully"
      
      - name: Check package
        run: |
          twine check dist/*
          echo "‚úÖ Package validation passed"
      
      # Uncomment to publish to PyPI (requires PYPI_API_TOKEN secret)
      # - name: Publish to PyPI
      #   env:
      #     TWINE_USERNAME: __token__
      #     TWINE_PASSWORD: ${{ secrets.PYPI_API_TOKEN }}
      #   run: |
      #     twine upload dist/*

  publish-node:
    runs-on: ubuntu-latest
    needs: [detect-changes, create-release]
    if: needs.detect-changes.outputs.has-node == 'true' && needs.detect-changes.outputs.should-release == 'true'
    steps:
      - uses: actions/checkout@v4
        with:
          ref: main
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          registry-url: 'https://registry.npmjs.org'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Build package
        run: |
          if npm run build --if-present; then
            echo "‚úÖ Build completed successfully"
          else
            echo "‚ÑπÔ∏è No build script found, skipping build"
          fi
      
      - name: Run tests
        run: |
          if npm test --if-present; then
            echo "‚úÖ Tests passed"
          else
            echo "‚ÑπÔ∏è No test script found, skipping tests"
          fi
      
      # Uncomment to publish to npm (requires NPM_TOKEN secret)
      # - name: Publish to npm
      #   env:
      #     NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
      #   run: |
      #     npm publish

  publish-rust:
    runs-on: ubuntu-latest
    needs: [detect-changes, create-release]
    if: needs.detect-changes.outputs.has-rust == 'true' && needs.detect-changes.outputs.should-release == 'true'
    steps:
      - uses: actions/checkout@v4
        with:
          ref: main
      
      - name: Setup Rust
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
          override: true
      
      - name: Build package
        uses: actions-rs/cargo@v1
        with:
          command: build
          args: --release
      
      - name: Run tests
        uses: actions-rs/cargo@v1
        with:
          command: test
      
      # Uncomment to publish to crates.io (requires CARGO_REGISTRY_TOKEN secret)
      # - name: Publish to crates.io
      #   env:
      #     CARGO_REGISTRY_TOKEN: ${{ secrets.CARGO_REGISTRY_TOKEN }}
      #   run: |
      #     cargo publish

  notify-release:
    runs-on: ubuntu-latest
    needs: [create-release, publish-python, publish-node, publish-rust]
    if: always() && needs.create-release.result == 'success'
    steps:
      - name: Notify release completion
        uses: actions/github-script@v7
        with:
          script: |
            const { context, github } = require('@actions/github');
            
            // Create a comment on the latest commit
            await github.rest.repos.createCommitComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              commit_sha: context.sha,
              body: `üöÄ **Release v${{ needs.create-release.outputs.new-version }} Published!**
              
              The automated release has been completed successfully.
              
              üì¶ **What was released:**
              - GitHub Release: [v${{ needs.create-release.outputs.new-version }}](https://github.com/${{ github.repository }}/releases/tag/v${{ needs.create-release.outputs.new-version }})
              ${needs.detect-changes.outputs.has-python == 'true' ? '- Python package built and ready for PyPI' : ''}
              ${needs.detect-changes.outputs.has-node == 'true' ? '- Node.js package built and ready for npm' : ''}
              ${needs.detect-changes.outputs.has-rust == 'true' ? '- Rust crate built and ready for crates.io' : ''}
              
              üéâ Great work on the new release!`
            });
            
            console.log('Release notification posted!');
